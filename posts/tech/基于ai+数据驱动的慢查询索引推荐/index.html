<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>基于AI&#43;数据驱动的慢查询索引推荐 | etermt&#39;s Blog</title>
<meta name="keywords" content="">
<meta name="description" content="随着美团业务量的不断增长，慢查询的数量也日益增多。目前，日均慢查询数量已经超过上亿条，如果仅依靠DBA和开发人员手动地对这些慢查询进行分析并建立合适的索引，显然是不太现实的。为了解决这一难题，美团内部DAS（数据库自治服务）平台已经集成了[基于代价的慢查询优化]建议来自动地为慢查询推荐索引。然而，仍然存在一些问题">
<meta name="author" content="美团技术团队">
<link rel="canonical" href="https://etermt.github.io/posts/tech/%E5%9F%BA%E4%BA%8Eai&#43;%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%85%A2%E6%9F%A5%E8%AF%A2%E7%B4%A2%E5%BC%95%E6%8E%A8%E8%8D%90/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.fba9be07063e799b58ee199bfc597784de87b24b8b123fca03d654df869df8c1.css" integrity="sha256-&#43;6m&#43;BwY&#43;eZtY7hmb/Fl3hN6HskuLEj/KA9ZU34ad&#43;ME=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js" integrity="sha256-rLVP0yu8GYJCi4hQMX5F0Ha5UBJzClk2Zn5rwhd3aSo="
        onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://etermt.github.io/img/me.jpg">
<link rel="icon" type="image/png" sizes="16x16" href="https://etermt.github.io/img/me.jpg">
<link rel="icon" type="image/png" sizes="32x32" href="https://etermt.github.io/img/me.jpg">
<link rel="apple-touch-icon" href="https://etermt.github.io/img/me.jpg">
<link rel="mask-icon" href="https://etermt.github.io/img/me.jpg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script defer src="https://unpkg.com/mermaid@8.8.1/dist/mermaid.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.6.3/dist/jquery.min.js"></script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = ""; 
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<meta property="og:title" content="基于AI&#43;数据驱动的慢查询索引推荐" />
<meta property="og:description" content="随着美团业务量的不断增长，慢查询的数量也日益增多。目前，日均慢查询数量已经超过上亿条，如果仅依靠DBA和开发人员手动地对这些慢查询进行分析并建立合适的索引，显然是不太现实的。为了解决这一难题，美团内部DAS（数据库自治服务）平台已经集成了[基于代价的慢查询优化]建议来自动地为慢查询推荐索引。然而，仍然存在一些问题" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://etermt.github.io/posts/tech/%E5%9F%BA%E4%BA%8Eai&#43;%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%85%A2%E6%9F%A5%E8%AF%A2%E7%B4%A2%E5%BC%95%E6%8E%A8%E8%8D%90/" />
<meta property="og:image" content="https://etermt.github.io/posts/tech/tech1/1.png" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-21T12:20:21+08:00" />
<meta property="article:modified_time" content="2023-02-21T12:20:21+08:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://etermt.github.io/posts/tech/tech1/1.png" />
<meta name="twitter:title" content="基于AI&#43;数据驱动的慢查询索引推荐"/>
<meta name="twitter:description" content="随着美团业务量的不断增长，慢查询的数量也日益增多。目前，日均慢查询数量已经超过上亿条，如果仅依靠DBA和开发人员手动地对这些慢查询进行分析并建立合适的索引，显然是不太现实的。为了解决这一难题，美团内部DAS（数据库自治服务）平台已经集成了[基于代价的慢查询优化]建议来自动地为慢查询推荐索引。然而，仍然存在一些问题"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [

        {
          "@type": "ListItem",
          "position":  1 ,
          "name": "文章",
          "item": "https://etermt.github.io/posts/"
        },

        {
          "@type": "ListItem",
          "position":  2 ,
          "name": "技术",
          "item": "https://etermt.github.io/posts/tech/"
        }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "基于AI+数据驱动的慢查询索引推荐",
      "item": "https://etermt.github.io/posts/tech/%E5%9F%BA%E4%BA%8Eai+%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%85%A2%E6%9F%A5%E8%AF%A2%E7%B4%A2%E5%BC%95%E6%8E%A8%E8%8D%90/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "基于AI+数据驱动的慢查询索引推荐",
  "name": "基于AI\u002b数据驱动的慢查询索引推荐",
  "description": "随着美团业务量的不断增长，慢查询的数量也日益增多。目前，日均慢查询数量已经超过上亿条，如果仅依靠DBA和开发人员手动地对这些慢查询进行分析并建立合适的索引，显然是不太现实的。为了解决这一难题，美团内部DAS（数据库自治服务）平台已经集成了[基于代价的慢查询优化]建议来自动地为慢查询推荐索引。然而，仍然存在一些问题",
  "keywords": [
    ""
  ],
  "articleBody": "1 背景 随着美团业务量的不断增长，慢查询的数量也日益增多。目前，日均慢查询数量已经超过上亿条，如果仅依靠DBA和开发人员手动地对这些慢查询进行分析并建立合适的索引，显然是不太现实的。为了解决这一难题，美团内部DAS（数据库自治服务）平台已经集成了基于代价的慢查询优化建议来自动地为慢查询推荐索引。然而，仍然存在一些问题：\n基于代价的慢查询优化建议是借助于优化器的代价估计，来推荐出对于查询代价改善最大的索引，但优化器的代价估计并不是完全准确[1]，因此可能存在着漏选或者错选推荐索引的问题。 基于代价的慢查询优化建议需要计算查询在不同索引下查询代价的改善程度，因此需要进行大量的增删索引操作，但真实增删索引的代价是非常大的，需要借助于假索引[2]技术，假索引技术并不创建真实的物理索引文件，只是通过模拟索引存在时的查询计划来估算索引对于查询的收益。目前，美团大部分业务都是运行在MySQL实例上的，不同于商业数据库SQL Server和开源数据库PostgreSQL，MySQL内部并没有集成假索引技术，因此需要自己构建支持假索引的存储引擎，其开发成本较高，这也是目前DAS平台基于代价的慢查询优化建议所采用的方案。 为了解决上述两个问题，美团数据库研发中心与华东师范大学数据科学与工程学院展开了《基于数据驱动的索引推荐》的科研合作，双方通过在DAS平台上集成基于AI+数据驱动的索引推荐，来与基于代价的方法并行地为慢查询推荐索引，以提升推荐效果。\n首先，基于代价的方法每天会为慢查询推荐索引，并在采样库上评估推荐的索引是否真正地改善了查询的执行时间，这为AI方法积累了大量可信的训练数据，根据此数据训练的AI模型，可以在一定程度上弥补基于代价的方法漏选或错选索引的问题。 其次，基于AI的方法将针对慢查询的索引推荐看作是二分类问题，通过分类模型直接判别在某一列或某些列上建立索引是否能够改善查询的执行性能，并不借助于查询优化器和假索引技术，这使得AI方法更加通用，且开发成本更低。 2 索引推荐介绍 索引推荐可以划分为两个级别：Workload级别和Query级别：\n在Workload级别，索引推荐是在限制的索引存储空间或索引个数下，推荐出一组最优的索引集合来使得整个Workload的代价最低。 Query级别的索引推荐可以被视为Workload级别索引推荐的简化版本，在Query级别，索引推荐是为单个慢查询推荐缺失的索引，以改善其性能。 2.1 基于代价的索引推荐 基于代价的索引推荐[3]大多聚焦于Workload级别的索引推荐，出现在查询中每一列或者列的组合都可以看作是一个能够改善Workload代价的候选索引，所有的候选索引构成了一个巨大的搜索空间（候选索引集合）。\n基于代价的索引推荐的目标，是在候选索引集合中搜索出一组最优索引集合，以最大程度地改善Workload代价。如果候选索引的个数N�，限制的最大推荐索引个数是M�，那么最优索引集合的搜索空间是：\nCMN=N∗(N−1)…(N−M+1)M!���=�∗(�−1)…(�−�+1)�!\n这是一个属于NP-hard范畴的搜索问题[4]。目前，基于代价的索引推荐方法大多会采用“贪心策略”来简化搜索过程，但这可能会导致最后推荐出的索引是次优解[5]。\n2.2 基于AI+数据驱动的索引推荐 基于AI+数据驱动的索引推荐聚焦于Query级别的索引推荐，出发点是在某个数据库中因为缺失索引导致的慢查询，在其它数据库中可能有相似的索引创建案例：这些查询语句相似，因此在相似位置上的列创建索引也可能带来类似的收益。例如下图中，查询qs��和qt��在语句结构和列类型上非常相似。因此，我们可以通过学习查询qs��的索引创建模式来为查询 qt��推荐缺失的索引。\n对于不同列数的索引推荐，我们会分别训练基于XGBoost的二分类模型。例如，我们目前最高支持三列的索引推荐，因此会分别训练一个单列索引推荐模型、一个两列索引推荐模型和一个三列索引推荐模型。对于给定的一个单列候选索引和它对应的慢查询，我们使用单列索引推荐模型来判断该单列候选索引是否能够改善该慢查询的性能。\n同样的，对于给定的一个两列（三列）候选索引和它对应的慢查询，我们使用两列（三列）索引推荐模型来判断这个两列（三列）候选索引是否能够改善该慢查询的性能。如果一条慢查询中包含的候选索引个数为N�，那么则需要N�次模型预测来完成对这条慢查询的索引推荐。\n3 整体架构 基于AI+数据驱动的索引推荐的整体架构如下图所示，主要分为两个部分：模型训练和模型部署。\n3.1 模型训练 如上文所述，我们收集DAS平台基于代价的慢查询优化建议每天的索引推荐数据（包括慢查询和被验证有效的推荐索引）作为训练数据。我们生成每条查询的单列、两列和三列候选索引，并通过特征工程来为每个候选索引构建特征向量，使用索引数据来为特征向量打标签。之后，单列、两列和三列特征向量将分别用于训练单列、两列和三列索引推荐模型。\n3.2 模型部署 针对需要推荐索引的慢查询，我们同样生成候选索引并构建特征向量。接下来，我们使用分类模型来预测特征向量的标签，即预测出候选索引中的有效索引。随后，我们在采样库上创建模型预测出的有效索引，并通过实际执行查询来观察建立索引前后查询性能是否得到改善。只有当查询性能真正得到改善时，我们才会将索引推荐给用户。\n4 建模过程 4.1 生成候选索引 我们提取查询中出现在聚合函数、WHERE、JOIN、ORDER BY、GROUP BY这些关键词中的列作为单列候选索引，并对这些单列候选索引进行排列组合来生成两列和三列候选索引。同时，我们会获取查询所涉及的表中已经存在的索引，并将其从候选索引集合中删除。这一步骤遵循索引的最左前缀原则：如果存在索引Idx(col1,col2)���(���1,���2)，那么候选索引 (col1)(���1) 和 (col1,col2)(���1,���2) 都将从候选索引集合中删除。\n4.2 特征工程 一个候选索引的特征向量包括语句特征和统计特征两部分。语句特征描述了候选索引列在查询中的出现位置（采用one-hot的编码方式），统计特征描述了候选索引列的统计信息，如所在表的表行数、Cardinality值、选择率等，这些是判断是否需要在候选索引列上建立索引的重要指标。\n下表以单列候选索引 (col1)(���1) 为例，展示了它的部分重要特征及其含义：\n两列候选索引 (col1,col2)(���1,���2) 的特征是通过对单列候选索引 (col1)(���1) 和 (col2)(���2) 的特征进行拼接而成的，此外，我们还会计算 col1���1 和 col2���2 共同的Cardinality值作为两列候选索引 (col1,col2)(���1,���2) 的额外统计特征，以更加全面地描述其统计信息。同样地，我们也会采用使用这种方式来构建三列候选索引 (col1,col2,col3)(���1,���2,���3) 的特征。在生成完一条查询的特征向量之后，我们使用这条查询使用到的索引来为生成的特征向量打标签。\n4.3 建模举例 下图以查询 q1�1 为例，展示我们为训练集中的一条查询生成特征向量并打标签的过程。查询 q1�1 涉及两张表customer表和warehouse表，其中customer表的c_w_id、c_id、c_d_id、c_last四列参与到查询中，因此对应生成四条单列特征向量；warehouse表的w_id列参与到查询中，因此只生成了一条单列特征向量。查询 q1�1 使用的单列索引为Idx(w_id)，所以单列候选索引 (w_id) 对应的特征向量被标记为正样本，其余特征向量则被标记为负样本。\n接下来，我们对单列候选索引进行排列组合来生成多列候选索引及其特征向量。由于查询 q1�1 使用到的多列索引只有一个三列索引Idx(c_d_id, c_id, c_last)，因此我们跳过生成两列候选索引，只生成三列候选索引。这是因为我们是基于查询使用到的索引来为特征向量打标签的，如果查询没有使用到两列索引，那么生成的所有两列特征向量均为负样本，这可能会导致训练集正负样本不均衡的问题。\n最后，基于查询使用到的三列索引，我们将三列候选索引 (c_d_id, c_id, c_last) 对应的特征向量标记为正样本。以上就是我们为查询 q1�1 生成特征向量并打标签的整个过程，查询 q1�1 为单列索引推荐模型的训练集贡献了五条样本（一条正样本，四条负样本），为三列索引推荐模型的训练集贡献了六条样本（一条正样本，五条负样本）。\n4.4 模型预测和索引评估 在为一条慢查询推荐索引时，我们依次生成慢查询中所有的单列、双列和三列候选索引，并通过上述的特征工程来构造特征向量。然后，我们将特征向量输入给对应的分类模型进行预测，并从三个分类模型的预测结果中分别挑选出一个预测概率最高的候选索引（即一个单列索引、一个两列索引和一个三列索引）作为模型推荐的索引。\n虽然推荐的索引越多，慢查询的性能就越有可能得到改善，但是模型推荐的部分索引可能是无效的，这些无效索引带来的存储空间开销和更新索引的开销是不可忽视的。因此，直接将模型推荐的索引全部推荐给用户是不合理的。为此，在将索引推荐给用户之前，我们会首先将三个分类模型推荐的索引建立在采样库上进行验证，采样库是线上数据库的一个mini版本，它抽取了线上数据库的部分数据。在采样库上，我们会观察在建立推荐的索引之后，查询的执行时间是否得到改善。如果得到改善，我们就把查询使用到的一个或多个模型推荐的索引作为索引建议推荐给用户。\n5 项目运行情况 正如前文所述，美团DAS平台目前采用代价方法和AI模型并行为慢查询推荐索引。具体来说，AI模型可以在某些场景下，弥补代价方法漏选或错选推荐索引的问题。就在刚过去的3月份，在代价方法推荐索引的基础上，AI模型有额外12.16%的推荐索引被用户所采纳。\n这些额外补充的索引对于查询的改善情况如上图所示：上半部分展示了优化的查询执行次数，下半部分展示了查询在使用推荐的索引之后的执行时间以及减少的执行时间，这些索引总计约优化了52亿次的查询执行，减少了4632小时的执行时间。\n6 未来规划 目前，大模型技术（如GPT-4）已经得到了越来越多的认可，几乎可以胜任各种领域的任务。我们计划尝试通过Fine-Tune开源的大型语言模型（如Google开源的T5模型）来解决索引推荐的问题：输入一条慢查询，让模型来生成针对慢查询的索引建议。\n在推荐索引无法改善慢查询的情况下，后续我们可以提供一些文本建议来帮助用户优化SQL，比如减少返回不必要的列，使用JOIN代替子查询等。\n7 本文作者 彭淦，美团基础研发平台工程师，主要负责美团数据库自治服务DAS的SQL优化建议工作。\n8 特别感谢 在这里特别感谢华东师范大学数据科学与工程学院的蔡鹏教授，教授在VLDB、ICDE、SIGIR、ACL等领域重要国际会议上发表多篇论文。目前的研究方向为内存事务处理，以及基于机器学习技术的自适应数据管理系统。本文也是美团数据库研发中心跟蔡鹏教授展开科研合作后的具体实践。\n美团科研合作致力于搭建美团技术团队与高校、科研机构、智库的合作桥梁和平台，依托美团丰富的业务场景、数据资源和真实的产业问题，开放创新，汇聚向上的力量，围绕机器人、人工智能、大数据、物联网、无人驾驶、运筹优化等领域，共同探索前沿科技和产业焦点宏观问题，促进产学研合作交流和成果转化，推动优秀人才培养。面向未来，我们期待能与更多高校和科研院所的老师和同学们进行合作。欢迎老师和同学们发送邮件至：meituan.oi@meituan.com。\n9 参考文献 [1] Leis V, Gubichev A, Mirchev A, et al. 2015. How good are query optimizers, really? Proc. VLDB Endow. 9, 3 (2015), 204-215. [2] https://github.com/HypoPG/hypopg [3] Kossmann J, Halfpap S, Jankrift M, et al. 2020. Magic mirror in my hand, which is the best in the land? an experimental evaluation of index selection algorithms. Proc. VLDB Endow. 13,12 (2020), 2382-2395. [4] Piatetsky-Shapiro G. 1983. The optimal selection of secondary indices is NP-complete. SIGMOD Record. 13,2 (1983), 72-75. [5] Zhou X, Liu L, Li W, et al. 2022. Autoindex: An incremental index management system for dynamic workloads. In ICDE. 2196-2208. ",
  "wordCount" : "4797",
  "inLanguage": "en",
  "image":"https://etermt.github.io/posts/tech/tech1/1.png","datePublished": "2023-02-21T12:20:21+08:00",
  "dateModified": "2023-02-21T12:20:21+08:00",
  "author":[{
    "@type": "Person",
    "name": "美团技术团队"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://etermt.github.io/posts/tech/%E5%9F%BA%E4%BA%8Eai+%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%85%A2%E6%9F%A5%E8%AF%A2%E7%B4%A2%E5%BC%95%E6%8E%A8%E8%8D%90/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "etermt's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://etermt.github.io/img/me.jpg"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    (function () {
        let  arr,reg = new RegExp("(^| )"+"change-themes"+"=([^;]*)(;|$)");
        if(arr = document.cookie.match(reg)) {
        } else {
            if (new Date().getHours() >= 19 || new Date().getHours() < 6) {
                document.body.classList.add('dark');
                localStorage.setItem("pref-theme", 'dark');
            } else {
                document.body.classList.remove('dark');
                localStorage.setItem("pref-theme", 'light');
            }
        }
    })()

    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }
</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://etermt.github.io/" accesskey="h" title="etermt&#39;s Blog (Alt + H)">etermt&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://etermt.github.io/archives/" title="时间轴">
                <span>时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://etermt.github.io/search" title="搜索 (Alt &#43; /)" accesskey=/>
                <span>搜索</span>
                </a>
            </li>
            <li>
                <a href="https://etermt.github.io/about" title="关于">
                <span>关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main page">
<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }
</style>

<article class="post-single">
    <div id="single-content">
        <header class="post-header">
            
            <h1 class="post-title">
                基于AI&#43;数据驱动的慢查询索引推荐
            </h1>
            <div class="post-description">
                随着美团业务量的不断增长，慢查询的数量也日益增多。目前，日均慢查询数量已经超过上亿条，如果仅依靠DBA和开发人员手动地对这些慢查询进行分析并建立合适的索引，显然是不太现实的。为了解决这一难题，美团内部DAS（数据库自治服务）平台已经集成了[基于代价的慢查询优化]建议来自动地为慢查询推荐索引。然而，仍然存在一些问题
            </div>
            <div class="post-meta">

<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }

    .parent-post-meta {
        display: flex;
        flex-wrap: wrap;
        opacity: 0.8;
    }
</style>

<span class="parent-post-meta">
    <span id="post_meta_style_1">
        <span class="fa fa-calendar-check-o"></span>
        <span>2023-02-21
            &nbsp;&nbsp;
        </span>
    </span>
    
    
    
    
    
    
    
    <span id="post_meta_style_3">
        <span class="fa fa-file-word-o"></span>
        <span>4797字
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_4">
        <span class="fa fa-clock-o"></span>
        <span>10分钟
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_5">
        <span class="fa fa-user-o"></span>
        <span>美团技术团队
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_6">
        <span class="fa fa-tags" style="opacity: 0.8"></span>
        <span>
            <span class="post-tags-meta">
                <a href="https://etermt.github.io/tags/ai/" style="color: var(--secondary)!important;">AI</a>
            </span>
        </span>
    </span>
</span>
<span style="opacity: 0.8;">
                    <span id="post_meta_style_7">
                        &nbsp;&nbsp;
                        <span class="fa fa-eye" ></span>
                        <span>
                            <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span></span>
                            &nbsp;&nbsp;
                        </span>
                    </span>
                    <span id="post_meta_style_8">
                        <span class="fa fa-commenting-o"></span>
                        <span>
                            <script src="https://cdn.staticfile.org/twikoo/1.5.8/twikoo.all.min.js"></script>
                            <script>
                                let url = document.documentURI
                                
                                let dnsUrl = "https://etermt.github.io/"
                                let urlSplit = url.split(dnsUrl)
                                let finalUrl = urlSplit[1]
                                if (finalUrl[0] !== '/') {
                                    finalUrl = '/'+finalUrl
                                }
                                twikoo.getCommentsCount({
                                    envId:  null , 
                                region:  null , 
                                urls: [ 
                                    
                                    finalUrl,
                                ],
                                    includeReply: false 
                                }).then(function (res) {
                                    let count = res[0].count
                                    const obj = document.getElementById("comment_count");
                                    obj.innerText = count
                                    
                                    
                                    
                                }).catch(function (err) {
                                    
                                    console.error(err);
                                });
                            </script>
                            <span id="comment_count"></span>
                        </span>
                    </span>
                </span>

</div>
        </header> 
<figure class="entry-cover1"><img style="zoom:50%;" loading="lazy" src="https://etermt.github.io/posts/tech/tech1/1.png" alt="">
    
</figure><aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">文章目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#1-%e8%83%8c%e6%99%af" aria-label="1 背景">1 背景</a></li>
                <li>
                    <a href="#2-%e7%b4%a2%e5%bc%95%e6%8e%a8%e8%8d%90%e4%bb%8b%e7%bb%8d" aria-label="2 索引推荐介绍">2 索引推荐介绍</a><ul>
                        
                <li>
                    <a href="#21-%e5%9f%ba%e4%ba%8e%e4%bb%a3%e4%bb%b7%e7%9a%84%e7%b4%a2%e5%bc%95%e6%8e%a8%e8%8d%90" aria-label="2.1 基于代价的索引推荐">2.1 基于代价的索引推荐</a></li>
                <li>
                    <a href="#22-%e5%9f%ba%e4%ba%8eai%e6%95%b0%e6%8d%ae%e9%a9%b1%e5%8a%a8%e7%9a%84%e7%b4%a2%e5%bc%95%e6%8e%a8%e8%8d%90" aria-label="2.2 基于AI&#43;数据驱动的索引推荐">2.2 基于AI+数据驱动的索引推荐</a></li></ul>
                </li>
                <li>
                    <a href="#3-%e6%95%b4%e4%bd%93%e6%9e%b6%e6%9e%84" aria-label="3 整体架构">3 整体架构</a><ul>
                        
                <li>
                    <a href="#31-%e6%a8%a1%e5%9e%8b%e8%ae%ad%e7%bb%83" aria-label="3.1 模型训练">3.1 模型训练</a></li>
                <li>
                    <a href="#32-%e6%a8%a1%e5%9e%8b%e9%83%a8%e7%bd%b2" aria-label="3.2 模型部署">3.2 模型部署</a></li></ul>
                </li>
                <li>
                    <a href="#4-%e5%bb%ba%e6%a8%a1%e8%bf%87%e7%a8%8b" aria-label="4 建模过程">4 建模过程</a><ul>
                        
                <li>
                    <a href="#41-%e7%94%9f%e6%88%90%e5%80%99%e9%80%89%e7%b4%a2%e5%bc%95" aria-label="4.1 生成候选索引">4.1 生成候选索引</a></li>
                <li>
                    <a href="#42-%e7%89%b9%e5%be%81%e5%b7%a5%e7%a8%8b" aria-label="4.2 特征工程">4.2 特征工程</a></li>
                <li>
                    <a href="#43-%e5%bb%ba%e6%a8%a1%e4%b8%be%e4%be%8b" aria-label="4.3 建模举例">4.3 建模举例</a></li>
                <li>
                    <a href="#44-%e6%a8%a1%e5%9e%8b%e9%a2%84%e6%b5%8b%e5%92%8c%e7%b4%a2%e5%bc%95%e8%af%84%e4%bc%b0" aria-label="4.4 模型预测和索引评估">4.4 模型预测和索引评估</a></li></ul>
                </li>
                <li>
                    <a href="#5-%e9%a1%b9%e7%9b%ae%e8%bf%90%e8%a1%8c%e6%83%85%e5%86%b5" aria-label="5 项目运行情况">5 项目运行情况</a></li>
                <li>
                    <a href="#6-%e6%9c%aa%e6%9d%a5%e8%a7%84%e5%88%92" aria-label="6 未来规划">6 未来规划</a></li>
                <li>
                    <a href="#7-%e6%9c%ac%e6%96%87%e4%bd%9c%e8%80%85" aria-label="7 本文作者">7 本文作者</a></li>
                <li>
                    <a href="#8-%e7%89%b9%e5%88%ab%e6%84%9f%e8%b0%a2" aria-label="8 特别感谢">8 特别感谢</a></li>
                <li>
                    <a href="#9-%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae" aria-label="9 参考文献">9 参考文献</a>
                </li>
            </ul>
        </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
        
        activeElement = elements[0];
        const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
        document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
    }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 &&
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
            const id = encodeURI(element.getAttribute('id')).toLowerCase();
            if (element === activeElement){
                document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
            } else {
                document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
            }
        })
    }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;
        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;
    }
</script>
        <div class="post-content"><h2 id="1-背景">1 背景<a hidden class="anchor" aria-hidden="true" href="#1-背景">#</a></h2>
<p>随着美团业务量的不断增长，慢查询的数量也日益增多。目前，日均慢查询数量已经超过上亿条，如果仅依靠DBA和开发人员手动地对这些慢查询进行分析并建立合适的索引，显然是不太现实的。为了解决这一难题，美团内部DAS（数据库自治服务）平台已经集成了<a href="https://tech.meituan.com/2022/04/21/slow-query-optimized-advice-driven-by-cost-model.html">基于代价的慢查询优化</a>建议来自动地为慢查询推荐索引。然而，仍然存在一些问题：</p>
<ul>
<li>基于代价的慢查询优化建议是借助于优化器的代价估计，来推荐出对于查询代价改善最大的索引，但优化器的代价估计并不是完全准确[1]，因此可能存在着漏选或者错选推荐索引的问题。</li>
<li>基于代价的慢查询优化建议需要计算查询在不同索引下查询代价的改善程度，因此需要进行大量的增删索引操作，但真实增删索引的代价是非常大的，需要借助于假索引[2]技术，假索引技术并不创建真实的物理索引文件，只是通过模拟索引存在时的查询计划来估算索引对于查询的收益。目前，美团大部分业务都是运行在MySQL实例上的，不同于商业数据库SQL Server和开源数据库PostgreSQL，MySQL内部并没有集成假索引技术，因此需要自己构建支持假索引的存储引擎，其开发成本较高，这也是目前DAS平台基于代价的慢查询优化建议所采用的方案。</li>
</ul>
<p>为了解决上述两个问题，美团数据库研发中心与华东师范大学数据科学与工程学院展开了《基于数据驱动的索引推荐》的科研合作，双方通过在DAS平台上集成基于AI+数据驱动的索引推荐，来与基于代价的方法并行地为慢查询推荐索引，以提升推荐效果。</p>
<ul>
<li>首先，基于代价的方法每天会为慢查询推荐索引，并在采样库上评估推荐的索引是否真正地改善了查询的执行时间，这为AI方法积累了大量可信的训练数据，根据此数据训练的AI模型，可以在一定程度上弥补基于代价的方法漏选或错选索引的问题。</li>
<li>其次，基于AI的方法将针对慢查询的索引推荐看作是二分类问题，通过分类模型直接判别在某一列或某些列上建立索引是否能够改善查询的执行性能，并不借助于查询优化器和假索引技术，这使得AI方法更加通用，且开发成本更低。</li>
</ul>
<h2 id="2-索引推荐介绍">2 索引推荐介绍<a hidden class="anchor" aria-hidden="true" href="#2-索引推荐介绍">#</a></h2>
<p>索引推荐可以划分为两个级别：Workload级别和Query级别：</p>
<ul>
<li>在Workload级别，索引推荐是在限制的索引存储空间或索引个数下，推荐出一组最优的索引集合来使得整个Workload的代价最低。</li>
<li>Query级别的索引推荐可以被视为Workload级别索引推荐的简化版本，在Query级别，索引推荐是为单个慢查询推荐缺失的索引，以改善其性能。</li>
</ul>
<h3 id="21-基于代价的索引推荐">2.1 基于代价的索引推荐<a hidden class="anchor" aria-hidden="true" href="#21-基于代价的索引推荐">#</a></h3>
<p>基于代价的索引推荐[3]大多聚焦于Workload级别的索引推荐，出现在查询中每一列或者列的组合都可以看作是一个能够改善Workload代价的候选索引，所有的候选索引构成了一个巨大的搜索空间（候选索引集合）。</p>
<p>基于代价的索引推荐的目标，是在候选索引集合中搜索出一组最优索引集合，以最大程度地改善Workload代价。如果候选索引的个数N�，限制的最大推荐索引个数是M�，那么最优索引集合的搜索空间是：</p>
<p>CMN=N∗(N−1)…(N−M+1)M!���=�∗(�−1)…(�−�+1)�!</p>
<p>这是一个属于NP-hard范畴的搜索问题[4]。目前，基于代价的索引推荐方法大多会采用“贪心策略”来简化搜索过程，但这可能会导致最后推荐出的索引是次优解[5]。</p>
<h3 id="22-基于ai数据驱动的索引推荐">2.2 基于AI+数据驱动的索引推荐<a hidden class="anchor" aria-hidden="true" href="#22-基于ai数据驱动的索引推荐">#</a></h3>
<p>基于AI+数据驱动的索引推荐聚焦于Query级别的索引推荐，出发点是在某个数据库中因为缺失索引导致的慢查询，在其它数据库中可能有相似的索引创建案例：这些查询语句相似，因此在相似位置上的列创建索引也可能带来类似的收益。例如下图中，查询qs��和qt��在语句结构和列类型上非常相似。因此，我们可以通过学习查询qs��的索引创建模式来为查询 qt��推荐缺失的索引。</p>
<p><img loading="lazy" src="https://p0.meituan.net/travelcube/e10b9e40c7d32e240b48ea7d8a08c2ab77425.png" alt="img"  />
</p>
<p>对于不同列数的索引推荐，我们会分别训练基于XGBoost的二分类模型。例如，我们目前最高支持三列的索引推荐，因此会分别训练一个单列索引推荐模型、一个两列索引推荐模型和一个三列索引推荐模型。对于给定的一个单列候选索引和它对应的慢查询，我们使用单列索引推荐模型来判断该单列候选索引是否能够改善该慢查询的性能。</p>
<p>同样的，对于给定的一个两列（三列）候选索引和它对应的慢查询，我们使用两列（三列）索引推荐模型来判断这个两列（三列）候选索引是否能够改善该慢查询的性能。如果一条慢查询中包含的候选索引个数为N�，那么则需要N�次模型预测来完成对这条慢查询的索引推荐。</p>
<h2 id="3-整体架构">3 整体架构<a hidden class="anchor" aria-hidden="true" href="#3-整体架构">#</a></h2>
<p>基于AI+数据驱动的索引推荐的整体架构如下图所示，主要分为两个部分：模型训练和模型部署。</p>
<p><img loading="lazy" src="https://p0.meituan.net/travelcube/2594f56cfda3718f4f426b62c8d4ece4208616.png" alt="img"  />
</p>
<h3 id="31-模型训练">3.1 模型训练<a hidden class="anchor" aria-hidden="true" href="#31-模型训练">#</a></h3>
<p>如上文所述，我们收集DAS平台基于代价的慢查询优化建议每天的索引推荐数据（包括慢查询和被验证有效的推荐索引）作为训练数据。我们生成每条查询的单列、两列和三列候选索引，并通过特征工程来为每个候选索引构建特征向量，使用索引数据来为特征向量打标签。之后，单列、两列和三列特征向量将分别用于训练单列、两列和三列索引推荐模型。</p>
<h3 id="32-模型部署">3.2 模型部署<a hidden class="anchor" aria-hidden="true" href="#32-模型部署">#</a></h3>
<p>针对需要推荐索引的慢查询，我们同样生成候选索引并构建特征向量。接下来，我们使用分类模型来预测特征向量的标签，即预测出候选索引中的有效索引。随后，我们在采样库上创建模型预测出的有效索引，并通过实际执行查询来观察建立索引前后查询性能是否得到改善。只有当查询性能真正得到改善时，我们才会将索引推荐给用户。</p>
<h2 id="4-建模过程">4 建模过程<a hidden class="anchor" aria-hidden="true" href="#4-建模过程">#</a></h2>
<h3 id="41-生成候选索引">4.1 生成候选索引<a hidden class="anchor" aria-hidden="true" href="#41-生成候选索引">#</a></h3>
<p>我们提取查询中出现在聚合函数、WHERE、JOIN、ORDER BY、GROUP BY这些关键词中的列作为单列候选索引，并对这些单列候选索引进行排列组合来生成两列和三列候选索引。同时，我们会获取查询所涉及的表中已经存在的索引，并将其从候选索引集合中删除。这一步骤遵循索引的最左前缀原则：如果存在索引Idx(col1,col2)���(���1,���2)，那么候选索引 (col1)(���1) 和 (col1,col2)(���1,���2) 都将从候选索引集合中删除。</p>
<h3 id="42-特征工程">4.2 特征工程<a hidden class="anchor" aria-hidden="true" href="#42-特征工程">#</a></h3>
<p>一个候选索引的特征向量包括语句特征和统计特征两部分。语句特征描述了候选索引列在查询中的出现位置（采用one-hot的编码方式），统计特征描述了候选索引列的统计信息，如所在表的表行数、Cardinality值、选择率等，这些是判断是否需要在候选索引列上建立索引的重要指标。</p>
<p>下表以单列候选索引 (col1)(���1) 为例，展示了它的部分重要特征及其含义：</p>
<p><img loading="lazy" src="https://p0.meituan.net/travelcube/dcc1f093fe87e708fe0988bad4038ab9332514.png" alt="img"  />
</p>
<p>两列候选索引 (col1,col2)(���1,���2) 的特征是通过对单列候选索引 (col1)(���1) 和 (col2)(���2) 的特征进行拼接而成的，此外，我们还会计算 col1���1 和 col2���2 共同的Cardinality值作为两列候选索引 (col1,col2)(���1,���2) 的额外统计特征，以更加全面地描述其统计信息。同样地，我们也会采用使用这种方式来构建三列候选索引 (col1,col2,col3)(���1,���2,���3) 的特征。在生成完一条查询的特征向量之后，我们使用这条查询使用到的索引来为生成的特征向量打标签。</p>
<h3 id="43-建模举例">4.3 建模举例<a hidden class="anchor" aria-hidden="true" href="#43-建模举例">#</a></h3>
<p>下图以查询 q1�1 为例，展示我们为训练集中的一条查询生成特征向量并打标签的过程。查询 q1�1 涉及两张表customer表和warehouse表，其中customer表的c_w_id、c_id、c_d_id、c_last四列参与到查询中，因此对应生成四条单列特征向量；warehouse表的w_id列参与到查询中，因此只生成了一条单列特征向量。查询 q1�1 使用的单列索引为Idx(w_id)，所以单列候选索引 (w_id) 对应的特征向量被标记为正样本，其余特征向量则被标记为负样本。</p>
<p>接下来，我们对单列候选索引进行排列组合来生成多列候选索引及其特征向量。由于查询 q1�1 使用到的多列索引只有一个三列索引Idx(c_d_id, c_id, c_last)，因此我们跳过生成两列候选索引，只生成三列候选索引。这是因为我们是基于查询使用到的索引来为特征向量打标签的，如果查询没有使用到两列索引，那么生成的所有两列特征向量均为负样本，这可能会导致训练集正负样本不均衡的问题。</p>
<p>最后，基于查询使用到的三列索引，我们将三列候选索引 (c_d_id, c_id, c_last) 对应的特征向量标记为正样本。以上就是我们为查询 q1�1 生成特征向量并打标签的整个过程，查询 q1�1 为单列索引推荐模型的训练集贡献了五条样本（一条正样本，四条负样本），为三列索引推荐模型的训练集贡献了六条样本（一条正样本，五条负样本）。</p>
<p><img loading="lazy" src="https://p0.meituan.net/travelcube/2ef80f225c53d534432bc873650e848e195441.png" alt="img"  />
</p>
<h3 id="44-模型预测和索引评估">4.4 模型预测和索引评估<a hidden class="anchor" aria-hidden="true" href="#44-模型预测和索引评估">#</a></h3>
<p>在为一条慢查询推荐索引时，我们依次生成慢查询中所有的单列、双列和三列候选索引，并通过上述的特征工程来构造特征向量。然后，我们将特征向量输入给对应的分类模型进行预测，并从三个分类模型的预测结果中分别挑选出一个预测概率最高的候选索引（即一个单列索引、一个两列索引和一个三列索引）作为模型推荐的索引。</p>
<p>虽然推荐的索引越多，慢查询的性能就越有可能得到改善，但是模型推荐的部分索引可能是无效的，这些无效索引带来的存储空间开销和更新索引的开销是不可忽视的。因此，直接将模型推荐的索引全部推荐给用户是不合理的。为此，在将索引推荐给用户之前，我们会首先将三个分类模型推荐的索引建立在采样库上进行验证，采样库是线上数据库的一个mini版本，它抽取了线上数据库的部分数据。在采样库上，我们会观察在建立推荐的索引之后，查询的执行时间是否得到改善。如果得到改善，我们就把查询使用到的一个或多个模型推荐的索引作为索引建议推荐给用户。</p>
<h2 id="5-项目运行情况">5 项目运行情况<a hidden class="anchor" aria-hidden="true" href="#5-项目运行情况">#</a></h2>
<p>正如前文所述，美团DAS平台目前采用代价方法和AI模型并行为慢查询推荐索引。具体来说，AI模型可以在某些场景下，弥补代价方法漏选或错选推荐索引的问题。就在刚过去的3月份，在代价方法推荐索引的基础上，AI模型有额外12.16%的推荐索引被用户所采纳。</p>
<p><img loading="lazy" src="https://p0.meituan.net/travelcube/c56866d0047beae28d3a087984b9f07c639595.png" alt="img"  />
</p>
<p>这些额外补充的索引对于查询的改善情况如上图所示：上半部分展示了优化的查询执行次数，下半部分展示了查询在使用推荐的索引之后的执行时间以及减少的执行时间，这些索引总计约优化了52亿次的查询执行，减少了4632小时的执行时间。</p>
<h2 id="6-未来规划">6 未来规划<a hidden class="anchor" aria-hidden="true" href="#6-未来规划">#</a></h2>
<p>目前，大模型技术（如GPT-4）已经得到了越来越多的认可，几乎可以胜任各种领域的任务。我们计划尝试通过Fine-Tune开源的大型语言模型（如Google开源的T5模型）来解决索引推荐的问题：输入一条慢查询，让模型来生成针对慢查询的索引建议。</p>
<p>在推荐索引无法改善慢查询的情况下，后续我们可以提供一些文本建议来帮助用户优化SQL，比如减少返回不必要的列，使用JOIN代替子查询等。</p>
<h2 id="7-本文作者">7 本文作者<a hidden class="anchor" aria-hidden="true" href="#7-本文作者">#</a></h2>
<p>彭淦，美团基础研发平台工程师，主要负责美团数据库自治服务DAS的SQL优化建议工作。</p>
<h2 id="8-特别感谢">8 特别感谢<a hidden class="anchor" aria-hidden="true" href="#8-特别感谢">#</a></h2>
<p>在这里特别感谢华东师范大学数据科学与工程学院的蔡鹏教授，教授在VLDB、ICDE、SIGIR、ACL等领域重要国际会议上发表多篇论文。目前的研究方向为内存事务处理，以及基于机器学习技术的自适应数据管理系统。本文也是美团数据库研发中心跟蔡鹏教授展开科研合作后的具体实践。</p>
<p>美团科研合作致力于搭建美团技术团队与高校、科研机构、智库的合作桥梁和平台，依托美团丰富的业务场景、数据资源和真实的产业问题，开放创新，汇聚向上的力量，围绕机器人、人工智能、大数据、物联网、无人驾驶、运筹优化等领域，共同探索前沿科技和产业焦点宏观问题，促进产学研合作交流和成果转化，推动优秀人才培养。面向未来，我们期待能与更多高校和科研院所的老师和同学们进行合作。欢迎老师和同学们发送邮件至：meituan.oi@meituan.com。</p>
<h2 id="9-参考文献">9 参考文献<a hidden class="anchor" aria-hidden="true" href="#9-参考文献">#</a></h2>
<ul>
<li>[1] Leis V, Gubichev A, Mirchev A, et al. 2015. How good are query optimizers, really? Proc. VLDB Endow. 9, 3 (2015), 204-215.</li>
<li>[2] <a href="https://github.com/HypoPG/hypopg">https://github.com/HypoPG/hypopg</a></li>
<li>[3] Kossmann J, Halfpap S, Jankrift M, et al. 2020. Magic mirror in my hand, which is the best in the land? an experimental evaluation of index selection algorithms. Proc. VLDB Endow. 13,12 (2020), 2382-2395.</li>
<li>[4] Piatetsky-Shapiro G. 1983. The optimal selection of secondary indices is NP-complete. SIGMOD Record. 13,2 (1983), 72-75.</li>
<li>[5] Zhou X, Liu L, Li W, et al. 2022. Autoindex: An incremental index management system for dynamic workloads. In ICDE. 2196-2208.</li>
</ul>


        </div>
        <div class="post-reward">
            <div style="padding: 0 0 0 0; margin: 0 0 0 0; width: 100%; font-size:16px; text-align: center;">
                <div id="QR" style="opacity: 0;">
                    <div id="wechat" style="display: inline-block">
                        <a class="fancybox" rel="group">
                            <img id="wechat_qr" src="https://etermt.github.io/img/wechat_pay.png" alt="wechat_pay"></a>
                        <p>微信</p>
                    </div>
                    <div id="alipay" style="display: inline-block">
                        <a class="fancybox" rel="group">
                            <img id="alipay_qr" src="https://etermt.github.io/img/alipay.png" alt="alipay"></a>
                        <p>支付宝</p>
                    </div>
                </div>
                <button id="rewardButton"
                        onclick="
                    var qr = document.getElementById('QR');
                    if (qr.style.opacity === '0') {
                        qr.style.opacity='1';
                    } else {
                        qr.style.opacity='0'
                    }"
                >
                    <span>🧧 鼓励</span>
                </button>
            </div>
        </div>

        <footer class="post-footer">
            
<nav class="paginav">
  <a class="next" href="https://etermt.github.io/posts/life/%E4%B9%A0%E8%BF%91%E5%B9%B3%E8%91%97%E4%BD%9C%E9%80%89%E8%AF%BB%E7%AC%AC%E4%B8%80%E5%8D%B7%E4%B8%BB%E8%A6%81%E7%AF%87%E7%9B%AE%E4%BB%8B%E7%BB%8D/">
    <span class="title">下一页 »</span>
    <br>
    <span>《习近平著作选读》第一卷主要篇目介绍</span>
  </a>
</nav>

        </footer>
    </div>

<style>
    .comments_details summary::marker {
        font-size: 20px;
        content: '👉展开评论';
        color: var(--content);
    }
    .comments_details[open] summary::marker{
        font-size: 20px;
        content: '👇关闭评论';
        color: var(--content);
    }
</style>


<div>
    <details class="comments_details">
        <summary style="cursor: pointer; margin: 50px 0 20px 0;width: 130px;">
            <span style="font-size: 20px;color: var(--content);">...</span>
        </summary>
        <div id="tcomment"></div>
    </details>
    <script src="https://cdn.staticfile.org/twikoo/1.5.8/twikoo.all.min.js">
    </script>
    <script>
        twikoo.init({
            envId:  null ,
        el: "#tcomment",
            lang: 'zh-CN',
            region:  null ,
        path: window.TWIKOO_MAGIC_PATH||window.location.pathname,
        })
    </script>
</div>
</article>
</main>

<footer class="footer">
    <span>
        Copyright
        &copy;
        2020-2023
        <a href="https://etermt.github.io/" style="color:#939393;">etermt&#39;s Blog</a>
        All Rights Reserved
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <span class="topInner">
        <svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z"/>
        </svg>
        <span id="read_progress"></span>
    </span>
</a>

<script>
    document.addEventListener('scroll', function (e) {
        const readProgress = document.getElementById("read_progress");
        const scrollHeight = document.documentElement.scrollHeight;
        const clientHeight = document.documentElement.clientHeight;
        const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
        readProgress.innerText = ((scrollTop / (scrollHeight - clientHeight)).toFixed(2) * 100).toFixed(0);
    })
</script>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });
</script>
<script>
    let mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 200 || document.documentElement.scrollTop > 200) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };
</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        (function() {
            document.cookie = "change-themes" + "="+ escape ("false");
        })()

        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    });
</script>

<script>
    document.body.addEventListener('copy', function (e) {
        if (window.getSelection().toString() && window.getSelection().toString().length > 50) {
            let clipboardData = e.clipboardData || window.clipboardData;
            if (clipboardData) {
                e.preventDefault();
                let htmlData = window.getSelection().toString() +
                    '\r\n\n————————————————\r\n' +
                    '版权声明：本文为「'+"etermt's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                '\r\n原文链接：' + location.href;
                let textData = window.getSelection().toString() +
                    '\r\n\n————————————————\r\n' +
                    '版权声明：本文为「'+"etermt's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                '\r\n原文链接：' + location.href;
                clipboardData.setData('text/html', htmlData);
                clipboardData.setData('text/plain', textData);
            }
        }
    });
</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;
        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = '📄复制';

        function copyingDone() {
            copybutton.innerText = '👌🏻已复制!';
            setTimeout(() => {
                copybutton.innerText = '📄复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                let text = codeblock.textContent +
                    '\r\n————————————————\r\n' +
                    '版权声明：本文为「'+"etermt's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                '\r\n原文链接：' + location.href;
                navigator.clipboard.writeText(text);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) {}
            selection.removeRange(range);
        });

        let language = codeblock.className.replaceAll("language-", "")
        let macTool = document.createElement("div")
        let macTool1 = document.createElement("div")
        let macTool2 = document.createElement("div")
        let macTool3 = document.createElement("div")
        let languageType = document.createElement("div")
        languageType.innerText = language
        macTool.setAttribute('class', 'mac-tool')
        macTool1.setAttribute('class', 'mac bb1')
        macTool2.setAttribute('class', 'mac bb2')
        macTool3.setAttribute('class', 'mac bb3')
        languageType.setAttribute('class', 'language-type')
        macTool.appendChild(macTool1)
        macTool.appendChild(macTool2)
        macTool.appendChild(macTool3)
        macTool.appendChild(languageType)

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
            container.appendChild(macTool)
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
            container.appendChild(macTool)
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
            container.appendChild(macTool)
        }
    });
</script>

<script>
    $("code[class^=language] ").on("mouseover", function () {
        if (this.clientWidth < this.scrollWidth) {
            $(this).css("width", "135%")
            $(this).css("border-top-right-radius", "var(--radius)")
        }
    }).on("mouseout", function () {
        $(this).css("width", "100%")
        $(this).css("border-top-right-radius", "unset")
    })
</script>
</body>

</html>
